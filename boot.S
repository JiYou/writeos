# 指定后面函数的起始位置
# 函数的入口地址在start标签处
.global start

# 指定后面的代码是在实模式下
# 也就是16位模式
.code16

# 下面是代码段开始了
.text
start:
	# 这里是让ds,es,ss三个段
	# 寄存器指向0地址。
	# 那么后面在访问数据的时候
	# 都是真实的地址
	mov $0,  	%ax
	mov %ax, 	%ds
	mov %ax, 	%es
	mov %ax, 	%ss
	# 这里栈是从boot sector
	# 拷贝到0x7c00之下的部分
	# 对于启动功能来说，暂时
	# 这个栈是够用的
	mov $0x7c00, 	%sp

	# 调用函数，就要开始使用栈了
	# 调用这个函数清理屏幕
	call ClearScreen
	# 调用函数来显示一些字符串
	#call DispStr

	# 是的，启动功能到这里就结束了
	# 这里不再演示更多的功能
	# 于是直接停机
	hlt

ClearScreen:
	# 这里是把后面会用到的寄存器都先压栈
	push %ax
	push %es
	push %bx
	push %ds
	# 显示的时候，注意格式
	# 0x07 可以解释为黑底白字,无闪烁,无加亮
	# <x86汇编语言－从实模式到保护模式》
	# 72页有详细介绍这部分内容。
	# 0x20也就是32。屏幕上显示的全是黑底
	# 白字的空白字符,也叫空格字符(Space),
	# ASCII 代码是 0x20,当你用大拇指按动
	# 键盘上最长的那个键时,就产生这个字符。
	# 因为它是空白,自然就 无法在黑底上看
	# 到任何痕迹了。

	# 这里把数据段指向显存缓冲区
	mov $0xb800, %ax
	mov %ax, %ds
	# bx寄存器用来计数
	# 默认的显示格式是80*25
	# 但是显存是这个数值的两倍，这是因为
	# 在显示一个字符的时候，需要设置两个char
	# 前面一个用来输出需要显示的字符
	# 后面一个用来指标显示的格式
	# 比如是什么颜色，是否需要闪烁啥的。
	mov $0x0, %bx

	for_loop:
		movb $0x20, (%bx)
		inc %bx
		movb $0x07, (%bx)
		inc %bx
		cmp $4000, %bx
		jnz for_loop

	# 清理屏幕结束
	pop %ds
	pop %bx
	pop %es
	pop %ax
	ret


END:
	# 启动扇区必须是512字节大小
	.org 510
	# 最后两个字节必须是固定的
	.word 0xaa55
